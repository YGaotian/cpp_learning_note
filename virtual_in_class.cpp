#include "header_learning.h"

void virtual_in_class()
{
	//普通函数的重载，我们称之为静态多态，因为函数的调用地址在编译阶段就能确定，属于早绑定（静态联编）
	/*
	而如果创建了一个父类的指针或引用，指向的是子类类型对象（这么做是可以的），当需要通过这个指针调用某一个方法时，一般会调用父类中的版本
	如果子类恰好定义了完全同名的函数，并执行子类版本的操作，父类指针是无法调用子类版本函数的，但是如果在父类的类声明中，在该函数声明（注意不是定义）前加上关键字virtual，就将该函数声明为虚函数了
	通过这种方法，使得当一个基类指针指向子类对象时，可以用基类指针调用其所指向的子类版本的方法
	*/
	/*
	每一个有虚函数的类（或有虚函数的类的派生类）都有一个虚函数表，该类的任何对象中都放着该虚函数表的指针，可以认为这是由编译器自动添加到构造函数中的指令完成的
	如果一个基类指针指向了子类对象，并且调用了某些方法，这样的程序在编译期间，系统并不会知道我们调用的是子类还是基类的方法，只有到了运行的时候，系统找到动态绑定到基类指针上的对象，它有可能是基类对象，也可能是子类对象
	然后系统内部根据该对象中的虚函数表指针，得到虚函数表。多态的函数调用语句被编译成根据基类指针所指向的（或基类引用所引用的）对象中存放的虚函数表的地址，在虚函数表中查找虚函数地址，并调用该虚函数
	这样所调用的虚函数就是动态绑定到基类指针上的对象的方法
	这属于晚绑定（动态联编），叫运行时多态或动态多态
	*/
	//值得注意的是，只需在父类声明中将该函数声明为虚函数即可，子类的该函数无需加上virtual关键字，但在子类中对该函数也加上virtual关键字并不会导致编译失败，并且可以提高代码的可读性
	Canine* can = new Dog;			//将匿名Dog对象动态绑定到了Canine指针上
	can->move(22);
	//显式调用父类版本的方法
	can->Canine::move(33);
	//最后，不要忘了释放内存，但需要注意的是，我们必须将基类的析构函数声明为虚函数，这样当我们delete基类指针时，不但基类的析构函数会被调用，基类指针所指向的子类实例的析构函数也会被调用
	//否则，子类实例的析构函数不会被调用，就发生了内存泄漏
	delete can;

	//在头文件中，使上面的代码可以被执行的这种做法，经常容易使我们在写代码时，将virtual关键字错写在子类的非虚函数的声明前，或者说，容易将子类中的某个函数当作从父类继承的虚函数重写
	//比如在基类中，声明了一个无参数的虚函数virtual void a()，我们可能会错误地在子类中声明一个同名但接收一个参数的函数void a(int)，导致我们以为重写了父类中的void a()，而其实是写了一个子类中的新函数
	//然后当我们用基类指针调用a()时，我们以为调用的是子类版本的a()，结果实际调用的却仍然是基类中的a()，因为子类中并不存在a()这个函数，而是一个新的函数a(int)
	//并且，当我们为了提高代码的可读性，将子类中继承自父类的虚函数也加上virtual声明时，也会导致一个结果，就是时隔多日后再回来看代码时，难以确定该函数是否是顶层的虚函数
	//意思是说，我们有时可能会很难区分该虚函数是继承自父类的虚函数，还是子类中的声明为virtual的新函数
	//于是c++11新增了保留字override
	//作用：
	// 1.在函数比较多的情况下可以提示读者某个函数重写了基类虚函数（表示这个虚函数是从基类继承，不是派生类自己定义的）
	// 2.强制编译器检查某个函数是否重写基类虚函数，如果没有则报错。
	//由此，可以有效地防止我们失误将virtual写在错误的函数前的目的，使得这种极难发现的错误变得显而易见，并且让我们可以在子类中继承自父类的虚函数前不写virtual并保证可读性，详见header_learning.h中Dog类声明

	//相反地，如果我们在基类中声明了一个虚函数，但我们并不希望在子类中重写覆盖该虚函数，我们可以在父类的（不是子类，与override相反）虚函数声明的末尾写上final，这样，一旦有任何子类尝试重写虚函数，编译器将会报错
	//我们也可以对类使用final，可以让一个类不能被其他类继承，方法是在该类的类声明时，在类名后面写final，如果有其他类在声明时想要继承该类，编译器会报错

	//纯虚函数：在基类中定义一个虚函数，但不写实现，这个虚函数不执行任何功能，但它要求任何子类必须做自己的实现，这个虚函数叫做纯虚函数，详见头文件中的Human类声明
	//一旦一个类中有一个纯虚函数，那么这个类就成为了一个抽象类，我们无法创建这个类的实例对象，所以子类必须亲自实现纯虚函数，否则子类也是一个抽象类，创建一个抽象类的实例会报错
	char name[20] = "Trump";
	Man man(name);			//Man是Human的子类，Human是一个抽象类
	man.getBirth();
	Man anotherman;
	anotherman.getBirth();

	//那么，如果我们要创建一个指向子类的抽象类指针呢？基类是一个抽象类，我们需要把这个抽象类的析构函数也定义为一个虚函数
	//抽象类的虚析构函数可以不是纯虚的，但如果我们将基类的析构函数定义为一个纯虚函数，是否意味着只需要写一个纯虚析构函数的声明virtual ~Human()=0;就行呢？答案并非如此
	//纯虚函数的=0并不意味着这个函数不可以有函数定义，它仅仅是告诉编译器该函数为纯虚函数，而真正的最终目的仅是告诉编译器该类是一个抽象类，不可以被实例化，所以只要有需求，纯虚函数当然也可以在函数体定义中执行任何操作
	//构造函数和析构函数和其它内部函数不一样，在调用时，编译器要产生一个调用链，子类的构造或析构函数被调用时，基类的也会被调用，所以基类的析构函数即使是纯虚函数，也要有函数体定义，详见本函数块下方的Human类函数定义
	Human* male = new Man();
	delete male;
}

//纯虚析构函数定义，可以不做任何事，但必须有函数体定义
Human::~Human()			//如果不执行任何操作，可以写成  Human::~Human() = default;  就不用写难看的花括号了
{
	std::cout << "Human destroyed." << std::endl;
}

Man::Man() = default;
Man::Man(char n[20])
{
	strcpy_s(name, n);
	std::cout << "A man is created" << std::endl;
}
void Man::getBirth()
{
	std::cout << "A man called " << name << " has born." << std::endl;
}
Man::~Man()
{
	std::cout << "Man destroyed." << std::endl;
}