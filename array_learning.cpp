#include "header_learning.h"

void array_learning()
{
	int ar[2] = { 1, 2 };
	//ar是数组ar的第一个元素的地址，&ar是整个数组的地址，它们意义不同，数值结果相同
	std::cout << "ar is:" << ar << std::endl;
	std::cout << "&ar is:" << &ar << std::endl;
	std::cout << "&ar[1] is:" << &ar[1] << " with value " << *&ar[1] << std::endl;
	std::cout << "*ar is:" << *ar << std::endl;
	int(*ap)[2] = &ar;
	//ap是一个指向int类型数组的指针，占4字节，打印ap就将其所指的数组的地址&ar打印了出来，数值结果与ar[0]的地址一样
	std::cout << ap << std::endl;
	//而打印*ap则将数组ar本身打印了出来，不过结果并不是以我们期望的{1, 2}形式显示的，而是将数组以其地址&ar的形式打印了出来，因为ar是数组第一个元素的地址
	std::cout << *ap << std::endl;
	//虽然上面两个打印出来的数值结果一样，但他们含义不同
	//按我们上面的说法，因为ap指向了这个数组，所以ap[1]就是将指向这个数组的指针往数组后偏移一个位置的内存地址，效果与ap+1一样，再对其解引用以获取它的值，即*ap[1]，打印一下，会发现值并不是数组的第二个int元素，而是一串奇怪的数字
	std::cout << *ap[1] << std::endl;
	//(A) 现在，先对指向这个数组地址的指针解引用，就是取这个数组本身，即*ap，再取它的第二个元素，因为[]优先级比*更高，所以要先用括号将*与ap结合，再用[]取元素，即(*ap)[1]，我们会得到数组中的第二个int元素
	std::cout << (*ap)[1] << std::endl;
	//通过上面两次输出，发现我们的说法没有错，下面这一行也再次证实了这一事实，ap的大小是4字节，是个指针，而*ap虽然数值结果与ap一样，但它是八个字节，是个数组
	std::cout << sizeof(ap) <<" "<< sizeof(*ap) << std::endl;
	//我们说过，ap是整个数组的地址，那我们当然可以通过直接对ap进行操作，获得数组中的元素，就像注释(A)下面的那一行一样，不过，我们也可以通过指针算数的方式实现
	//现在已知的是，数组名是数组的第一个元素的地址，而ap指向整个数组的地址，也就是说，我们可以将ap当成二级指针使用，对其解引用一次，得到表示数组ar本身，即ar中第一个元素的地址
	//此时我们再将它+1，就得到了第一个元素的地址再向后偏移一位的地址，对其解引用*(*ap + 1)，就得到了数组中的第二个int元素的值
	std::cout << *(*ap + 1) << std::endl;
}