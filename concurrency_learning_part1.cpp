#include "header_learning.h"
#include <thread>

/*---------------------------------------------------------------------------------------------------------------------------------------------------------------------
并发（concurrency）的意思是在多个任务间来回切换执行，以实现在同一时间段内程序处理多个任务，这种任务的切换（也称为上下文切换）是需要时间开销的
因为在切换前，需要先保存当前任务的运行状态，进度等，然后切换到另一个任务，之后再切换回来的时候还要对之前保存的信息进行复原
由于计算机硬件的发展，逐渐出现了多核cpu，于是就产生了真正的同步运行多个任务的手段，这种真正的同步运行称为并行（parallelism）

进程：一个可执行程序运行起来，就创建了一个进程

线程：每当一个进程被创建，就必定会产生一个属于这个进程的唯一的主线程，程序运行的时候，实际上都是主线程在调用main函数中的代码，main执行完了，主线程生命就结束了，进程也就随主线程结束了，它们是同时生灭的

多线程：除了自动创建的主线程外，我们还可以自己写代码创建新的线程，这样就可以在同一时间段内做多件事情，但每个线程都需要一个独立的堆栈空间，占用内存大小为1M，并且线程间的切换也需要时间，所以线程绝不是越多越好
      创建的线程的数量，一般建议不超过200~300个

并发的实现方式：可以用多个不同的进程实现并发，也可以在单独的进程中用不同的线程实现并发
            不同的进程之间可以互相通讯
            同一个进程内的不同的线程之间是共享内存的，全局变量，指针，引用都可以在线程之间进行传递，并且线程的起动速度比进程更快，所以多线程的开销远小于多进程的开销
               但多线程会带来数据一致性的问题，就是多个线程可能在同一时段内对同一块内存写入不同的数据，这样就会导致写好的数据被覆盖，所以我们需要手动地控制多线程的处理顺序
            虽然多进程和多线程可以混合使用，但在多进程和多线程之间，应该更优先考虑使用多线程

线程的创建：主线程从main函数开始运行，我们自己手动创建的线程，也需要从一个初始函数开始运行。然而，线程其实并不是只能用一个函数对象来创建，任何可调用对象都可以作为实参去构造一个线程对象
         我们自己创建的线程，都是跟着进程的主线程的，一旦主线程终止了，那么其他所有的子线程即使没执行完，也会跟着结束，判断一个进程是否执行完毕的标志就是看主线程是否终止
         所以如果我们希望子线程保持运行，就要保证主线程一直保持运行，不被终止，但其实这个规则有例外，后续再做讨论
---------------------------------------------------------------------------------------------------------------------------------------------------------------------*/

void myThreadInitialFunc_1()
{
    std::cout << "线程1 开始执行 " << std::endl;

    //do something
 
    std::cout << "线程1 结束执行" << std::endl;
}

void myThreadInitialFunc_2()
{
    std::cout << "线程2 开始执行 " << std::endl;

    //do something

    std::cout << "线程2 结束执行 " << std::endl;
}

//仿函数
class ThreadFunctor
{
public:
    void operator()()
    {
        std::cout << "仿函数对象有了一个自己的线程 " << std::endl;
    }
};

void concurrency_learning_part1()
{
    //在创建线程之前，我们需要先包含头文件“thread”
    //现在创建一个线程对象，并将初始函数加进来
    //两个线程是互相独立执行的，所以即使其中一个线程堵塞了，另一个线程也会继续执行任务
    //创建线程1
    std::thread myThread_1(myThreadInitialFunc_1);
    //join()的意思是等待子线程加入到主线程中，也就是说等子线程执行完毕，再回到主线程，此过程中主线程会被阻塞，并等待子线程myThread_1执行完毕，再回到主线程，继续执行后面的任务
    myThread_1.join();

    //创建线程2
    std::thread myThread_2(myThreadInitialFunc_2);
    //detach()将子线程与主线程分离，这样主线程不会被阻塞，即使主线程结束，子线程如果没有运行完，也会在后台持续存在(称为守护线程)，被c++运行时库所接管，任务结束时由运行时库自动清理该线程相关的资源，这就是前言中最后所讲的例外
    myThread_2.detach();    //一旦一个线程调用了detach，就不能再用join接管回来了，这个线程就不再受主线程的生命周期影响

    //joinable()可以用来判断一个线程是否可以成功使用join()或者detach()
    if (not (myThread_1.joinable() or myThread_2.joinable()))
        std::cout << "无法join或detach，因为前面已经join或detach过了 " << std::endl;

    //仿函数也是一个可调用对象，所以我们也可以将一个仿函数作为参数，去创建一个线程对象
    ThreadFunctor ft;
    std::thread myThread_3(ft);
    myThread_3.detach();

    //使用detach()时，要慎用引用，如果仿函数a的构造函数需要使用引用，比如在主线程中创建了一个对象x和一个仿函数a，其中仿函数a使用对象x的引用来实例化自己，然后创建线程对象的时候传进了仿函数a
    //那么一旦主线程比子线程先执行完毕，这时主线程中的对象x就会被销毁
    //那么子线程中就无法再正确的使用对象x的引用了
    //而上面的代码中，ft是一个在主线程中创建的仿函数，但是如果主线程先结束，子线程myThread_3依然可以正常运行，这是因为创建myThread_3的时候传入的是ft而不是&ft，所以ft是被拷贝到子线程中去的，这样的话主线程结束，子线程不会受影响

    //lambda表达式也可以创建一个线程

    std::cout << "concurrency_learning part 1 ended " << std::endl;
}
