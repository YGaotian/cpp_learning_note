#include "header_learning.h"

void defense_declared_header()
{
	std::cout << "如果头文件中只包含声明语句的话，它被同一个 .cpp 文件包含 "
		<< "再多次都没问题――因为声明语句的出现是不受限制的。然而，上面讨论到的头文件 "
		<< "中的三个例外也是头文件很常用的一个用处。那么，一旦一个头文件中出现了上面三个 "
		<< "例外中的任何一个，它再被一个 .cpp 包含多次的话，问题就大了。因为这三个例外中的语法元素虽然 "
		<< "可以定义在多个源文件中，但是在一个源文件中只能出现一次。设想一下，如果 a.h 中 "
		<< "含有类 A 的定义，b.h 中含有类 B 的定义，由于类B的定义依赖了类 A，所以 b.h 中 "
		<< "也 #include了a.h。现在有一个源文件，它同时用到了类A和类B，于是程序员在这个源文件中 "
		<< "既把 a.h 包含进来了，也把 b.h 包含进来了。这时，问题就来了：类A的定义在这个源文件中 "
		<< "出现了两次！于是整个程序就不能通过编译了。你也许会认为这是程序员的失误――他应该知 "
		<< "道 b.h 包含了 a.h ――但事实上他不应该知道。使用 #define 配合条件编译可以很好地解 "
		<< "决这个问题。在一个头文件中，通过 #define 定义一个名字，并且通过条件编译 "
		<< "#ifndef...#endif 使得编译器可以根据这个名字是否被定义，再决定要不要继续编译该头文中后续 "
		<< "的内容。这个方法虽然简单，但是写头文件时一定记得写进去。 " << std::endl;
}