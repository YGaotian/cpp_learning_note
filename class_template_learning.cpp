#include "header_learning.h"
#include "class_template_learning.hpp"

void class_template()
{
	//编译器并不能为类模板自动推断类型，所以必须显式地传入类型参数
	//由于模板是在编译期间遇到具体的使用才会生成具体的代码，所以对于类模板来说，如果将类模板写在头文件中，这个头文件内只含有成员函数的声明，而模板类中的函数体实现写在单独的cpp文件中的做法并不好
	// 因为程序编译期间，只要这些代码没有语法错误，就不会报错，编译就会通过，如果在其他cpp文件中要实例化这个模板类，调用类成员函数，编译期间需要根据类模板中成员函数的定义生成特定类型的类定义代码
	// 但是通常cpp文件只include头文件，而类模板中的函数体却在另一个cpp文件中，由于在编译阶段，每个编译单元暂时并没有被链接，会导致想要实例化模板类的这个cpp文件只含有头文件中的类模板声明
	// 却找不到存在于另一个cpp文件内的类成员函数的函数体，所以会报错，想要解决这个错误就必须将函数体所在的cpp文件也include进来，但是直接include一个cpp文件并不规范
	//所以，我们必须将类模板声明和模板类的成员函数体都写出来在同一个头文件内，而这个头文件的后缀名可以写成.hpp，而不是通常的.h，以此表示这个头文件中不仅有声明，而且还有实现
	//在header_learning.h的MyClass部分说过，如果将函数体写在类声明里面，其实是隐式地将这个函数声明为了内联函数，编译器会把这个函数当做内联函数处理，但具体是否内联，取决于编译器对具体代码的判断，类模板也是如此
	//与普通类的成员函数不同，对于类模板，我们就算将成员函数的实现写在头文件中的类声明外，也不会引起重定义，《C++编程思想》第15章(第300页)说明了原因：
    //  模板定义很特殊。由template<…> 处理的任何东西都意味着编译器在当时不为它分配存储空间，它一直处于等待状态直到被一个模板实例告知
    //  在编译器和链接器的某一处，有一机制能去掉指定模板的多重定义。所以为了容易使用，几乎总是在头文件中放置全部的模板声明和定义
	MyList<double> mDblList;
	MyList<std::string, 5> mStrList;
}